import {Inject, Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { User, UserDocument } from '../user.entity';
import {RandomUsernameGenerator} from '../utils/random-username.generator';
import {JwtService} from "@nestjs/jwt";
import * as bcrypt from 'bcrypt';
import {UsernameAlreadyRegisteredException} from "../exceptions/username-already-registered.exception";
import {InvalidUsernameOrPasswordException} from "../exceptions/invalid-username-or-password.exception";

@Injectable()
export class UserService {
    @Inject(RandomUsernameGenerator)
    private readonly randomUsernameGenerator: RandomUsernameGenerator;

    @Inject(JwtService)
    private readonly jwtService: JwtService;

    constructor(
        @InjectModel(User.name) private readonly userRepository: Model<UserDocument>
    ) {}

    async createRandomUser(): Promise<UserDocument> {
        const user = new User();
        user.username = this.randomUsernameGenerator.generate();
        user.isAutoGenerated = true;

        return await this.userRepository.create(user);
    }

    async registerUser(username: string, password: string): Promise<UserDocument> {
        if (await this.isUsernameRegistered(username)) {
            throw new UsernameAlreadyRegisteredException();
        }

        const salt = await bcrypt.genSalt(Number(process.env.PASSWORD_SALT_SIZE));
        const hashedPassword = await bcrypt.hash(password, salt);
        const user = new User();
        user.username = username;
        user.password = hashedPassword;
        user.isAutoGenerated = false;

        return await this.userRepository.create(user);
    }

    getJwt(user: UserDocument): string {
        const payload = { username: user.username, sub: user._id };

        return this.jwtService.sign(payload);
    }

    async isUsernameRegistered(username: string) {
        const model = this.getUser(username);

        return !!model;
    }

    async getUser(username: string) {
        return await this.userRepository.findOne({
            username: username
        });
    }

    async validateUser(username: string, password: string) {
        const user = await this.getUser(username);

        if (!user) {
            throw new InvalidUsernameOrPasswordException();
        }

        const passwordValid = await bcrypt.compare(password, user.password);

        if (!passwordValid) {
            throw new InvalidUsernameOrPasswordException();
        }

        return user;
    }
}